{% extends "base.html" %}

{% block styles %}
<style>
    .ip-address-width {
        width: 200px !important;
    }
    .array-item {
        padding: 1rem;
        margin-bottom: 1rem;
        border-radius: 4px;
        width: 100%;
    }
    .array-item .form-control {
        margin-right: 0;
    }
    .array-item .btn-danger {
        padding: 0.25rem 0.5rem;
    }
    .template-section {
        padding: 1rem;
        margin-bottom: 1rem;
        border-radius: 4px;
        width: 100%;
        overflow-x: auto;
        border-bottom: 1px solid #dee2e6;
    }
    .template-section:last-child {
        border-bottom: none;
    }
    .template-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #f8f9fa;
        padding: 0.75rem 1rem;
        margin-bottom: 1rem;
        border-radius: 4px;
        border-left: 4px solid #0d6efd;
    }
    .template-name {
        font-weight: 600;
        color: #2c3e50;
    }
    .template-actions {
        display: flex;
        gap: 0.5rem;
    }
    .interface-divider {
        margin: 1rem 0;
        border-top: 1px solid #dee2e6;
    }
    .interface-item {
        padding: 1rem;
        margin-bottom: 1rem;
        border-radius: 4px;
        width: 100%;
    }
    .editable-value {
        cursor: pointer;
    }
    .editable-value:hover {
        background-color: #e9ecef;
        border-radius: 4px;
    }
    .variables-column {
        padding: 1rem;
        background-color: white;
        border-radius: 4px;
        width: 100%;
    }
    .row.mb-2.align-items-center {
        display: flex;
        min-width: max-content;
        margin-right: 0;
        margin-left: 0;
    }
    .row.mb-2.align-items-center .col-4 {
        flex: 0 0 auto;
        padding-right: 1rem;
        color: #495057;
    }
    .row.mb-2.align-items-center .col-8 {
        flex: 1 1 auto;
    }
    .value-display {
        display: inline-block;
        min-width: max-content;
    }
    .container-fluid {
        min-width: max-content;
        padding-bottom: 2rem;
    }
    .row {
        min-width: max-content;
        margin-right: 0;
        margin-left: 0;
    }
    /* Regular cards (non-preview) */
    .card {
        margin-bottom: 1rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        height: 100%;
    }
    /* Preview specific styles */
    .preview-column {
        height: calc(100vh - 120px);
    }
    .preview-column .card {
        height: 100%;
    }
    .preview-column .card-body {
        height: calc(100% - 40px);  /* Account for card header */
        padding: 0;  /* Remove padding as it will be handled by the pre element */
    }
    #configPreview {
        padding: 1rem;
        background-color: #f8f9fa;
        border: none;
        height: 100%;
        min-height: 500px;
    }
    /* Reset other columns to their default behavior */
    .col-1, .col-2, .col-3:not(.preview-column) {
        height: auto;
    }
    .col-1 .card, .col-2 .card, .col-3:not(.preview-column) .card {
        height: auto;
    }
    .col-1 .card-body, .col-2 .card-body {
        height: auto;
        padding: 0;  /* Remove padding as list items have their own padding */
    }
    .list-group-item {
        padding: 0.5rem 1rem;
        border: none;
        border-bottom: 1px solid rgba(0,0,0,0.1);
    }
    .list-group-item:last-child {
        border-bottom: none;
    }
    /* Updated layout styles */
    .main-content {
        padding: 2rem 1rem;
    }

    .card-header {
        background-color: white;
        border-bottom: 1px solid rgba(0,0,0,0.1);
        padding: 0.75rem 1rem;
    }

    .card-header h6 {
        margin: 0;
        font-weight: 500;
    }

    .card-body {
        padding: 0;
    }

    /* Sync button styling */
    .sync-section {
        margin-bottom: 1.5rem;
    }

    #syncButton {
        padding: 0.5rem 1rem;
    }

    #syncStatus {
        margin-left: 1rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid main-content">
    <!-- Git Sync Button -->
    <div class="row sync-section">
        <div class="col-12">
            <button id="syncButton" class="btn btn-primary">
                <i class="fas fa-sync"></i> Sync with GitLab
            </button>
            <span id="syncStatus" class="ml-2"></span>
        </div>
    </div>

    <div class="row">
        <!-- Node Structure -->
        <div class="col-1">
            <div class="card">
                <div class="card-header">
                    <h6>Family</h6>
                </div>
                <div class="card-body">
                    <div id="nodeFamilyList" class="list-group list-group-flush"></div>
                </div>
            </div>
        </div>

        <div class="col-1">
            <div class="card">
                <div class="card-header">
                    <h6>Class</h6>
                </div>
                <div class="card-body">
                    <div id="nodeClassList" class="list-group list-group-flush"></div>
                </div>
            </div>
        </div>

        <div class="col-2">
            <div class="card">
                <div class="card-header">
                    <h6>Node Name</h6>
                </div>
                <div class="card-body">
                    <div id="nodeNameList" class="list-group list-group-flush"></div>
                </div>
            </div>
        </div>

        <!-- Templates -->
        <div class="col-2">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h6>Templates</h6>
                    <button id="addTemplateBtn" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
                <div class="card-body">
                    <div id="templateList" class="list-group list-group-flush"></div>
                </div>
            </div>
        </div>

        <!-- Variables -->
        <div class="col-3">
            <div class="card">
                <div class="card-header">
                    <h6>Variables</h6>
                </div>
                <div class="card-body">
                    <div id="variableList"></div>
                </div>
            </div>
        </div>

        <!-- Preview -->
        <div class="col-3">
            <div class="card">
                <div class="card-header">
                    <h6>Preview</h6>
                </div>
                <div class="card-body">
                    <pre id="configPreview"></pre>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let currentPath = {
    family: null,
    class: null,
    node: null,
    templates: []
};

// Add a global variable to track hidden interfaces
let hiddenInterfaces = new Set();

// Add at the start of the script section, right after currentPath declaration
function saveCurrentPath() {
    localStorage.setItem('configHubPath', JSON.stringify({
        family: currentPath.family,
        class: currentPath.class,
        node: currentPath.node,
        templates: currentPath.templates
    }));
}

function restoreCurrentPath() {
    const saved = localStorage.getItem('configHubPath');
    if (saved) {
        try {
            const path = JSON.parse(saved);
            if (path.family && path.class && path.node) {
                currentPath = path;
                // The actual UI update will happen through the structure loading
                return path;
            }
        } catch (error) {
            logger.error('path-restore', 'Failed to restore path', { error: error.message });
            localStorage.removeItem('configHubPath');
        }
    }
    return null;
}

// Load initial structure
function loadStructure() {
    const savedPath = restoreCurrentPath();
    
    return fetch('{{ url_for("config.get_structure") }}')
        .then(response => response.json())
        .then(data => {
            const familyList = document.getElementById('nodeFamilyList');
            familyList.innerHTML = '';
            
            data.families.forEach(family => {
                const item = document.createElement('a');
                item.href = '#';
                item.className = 'list-group-item list-group-item-action py-2';
                item.textContent = family.name;
                item.onclick = () => selectFamily(family);
                familyList.appendChild(item);
                
                // If this is the saved family, trigger selection
                if (savedPath && family.name === savedPath.family) {
                    const savedFamily = data.families.find(f => f.name === savedPath.family);
                    if (savedFamily) {
                        selectFamily(savedFamily);
                        
                        // Find and select the saved class
                        const savedClass = savedFamily.classes.find(c => c.name === savedPath.class);
                        if (savedClass) {
                            setTimeout(() => {
                                selectClass(savedClass);
                                
                                // Find and select the saved node
                                const savedNode = savedClass.nodes.find(n => n.name === savedPath.node);
                                if (savedNode) {
                                    setTimeout(() => {
                                        selectNode(savedNode);
                                    }, 100);
                                }
                            }, 100);
                        }
                    }
                }
            });
        });
}

// Select node family
function selectFamily(family) {
    currentPath.family = family.name;
    currentPath.class = null;
    currentPath.node = null;
    currentPath.templates = [];
    
    // Update UI
    document.querySelectorAll('#nodeFamilyList a').forEach(a => 
        a.classList.toggle('active', a.textContent === family.name));
    
    // Update class list
    const classList = document.getElementById('nodeClassList');
    classList.innerHTML = '';
    
    family.classes.forEach(nodeClass => {
        const item = document.createElement('a');
        item.href = '#';
        item.className = 'list-group-item list-group-item-action py-2';
        item.textContent = nodeClass.name;
        item.onclick = () => selectClass(nodeClass);
        classList.appendChild(item);
    });
    
    // Clear subsequent lists
    document.getElementById('nodeNameList').innerHTML = '';
    document.getElementById('templateList').innerHTML = '';
    document.getElementById('variableList').innerHTML = '';
    document.getElementById('configPreview').textContent = '';
    saveCurrentPath();
}

// Select node class
function selectClass(nodeClass) {
    currentPath.class = nodeClass.name;
    currentPath.node = null;
    currentPath.templates = [];
    
    // Update UI
    document.querySelectorAll('#nodeClassList a').forEach(a => 
        a.classList.toggle('active', a.textContent === nodeClass.name));
    
    // Update node list
    const nodeList = document.getElementById('nodeNameList');
    nodeList.innerHTML = '';
    
    nodeClass.nodes.forEach(node => {
        const item = document.createElement('a');
        item.href = '#';
        item.className = 'list-group-item list-group-item-action py-2';
        item.textContent = node.name;
        item.onclick = () => selectNode(node);
        nodeList.appendChild(item);
    });
    
    // Clear subsequent lists
    document.getElementById('templateList').innerHTML = '';
    document.getElementById('variableList').innerHTML = '';
    document.getElementById('configPreview').textContent = '';
    saveCurrentPath();
}

// Add these functions at the start of the script section
function saveTemplateSelections() {
    const key = `${currentPath.family}/${currentPath.class}/${currentPath.node}/templates`;
    localStorage.setItem(key, JSON.stringify(currentPath.templates));
}

function loadTemplateSelections(availableTemplates) {
    const key = `${currentPath.family}/${currentPath.class}/${currentPath.node}/templates`;
    const saved = localStorage.getItem(key);
    if (saved) {
        try {
            const savedTemplates = JSON.parse(saved);
            // Only restore templates that still exist
            currentPath.templates = savedTemplates.filter(template => 
                availableTemplates.some(t => t.name === template)
            );
            
            // If some templates were filtered out (no longer exist), update storage
            if (currentPath.templates.length !== savedTemplates.length) {
                saveTemplateSelections();
                logger.info('template-state', 'Removed non-existent templates from saved selection');
            }
            
            // Update checkboxes to match validated state
            document.querySelectorAll('#templateList input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = currentPath.templates.includes(checkbox.dataset.template);
            });
            
            if (currentPath.templates.length > 0) {
                refreshTemplateState();
            }
        } catch (error) {
            logger.error('template-state', 'Failed to parse saved template selections', { error: error.message });
            localStorage.removeItem(key);
            currentPath.templates = [];
        }
    }
}

// Modify the selectNode function to pass available templates
function selectNode(node) {
    logger.debug('node-selection', 'Selecting node', { node });
    
    currentPath.node = node.name;
    currentPath.templates = [];
    hiddenInterfaces.clear();
    
    // Update UI
    document.querySelectorAll('#nodeNameList a').forEach(a => 
        a.classList.toggle('active', a.textContent === node.name));
    
    // Load templates
    fetch(`{{ url_for("config.get_templates", node_path="") }}${node.path}`)
        .then(response => response.json())
        .then(templates => {
            logger.debug('templates', 'Loading templates', { templates });
            
            const templateList = document.getElementById('templateList');
            templateList.innerHTML = '';
            
            templates.forEach(template => {
                const item = document.createElement('div');
                item.className = 'list-group-item py-2 d-flex justify-content-between align-items-center';
                
                const leftSection = document.createElement('div');
                leftSection.className = 'd-flex align-items-center';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'me-2';
                checkbox.dataset.template = template.name;
                checkbox.onchange = () => {
                    if (checkbox.checked) {
                        currentPath.templates.push(template.name);
                    } else {
                        currentPath.templates = currentPath.templates.filter(t => t !== template.name);
                    }
                    saveTemplateSelections();
                    saveCurrentPath();
                    refreshTemplateState();
                };
                
                const label = document.createElement('label');
                label.className = 'mb-0 ms-2';
                label.textContent = template.name;
                
                leftSection.appendChild(checkbox);
                leftSection.appendChild(label);
                
                const editBtn = document.createElement('button');
                editBtn.className = 'btn btn-sm btn-outline-secondary';
                editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                editBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!currentPath.family || !currentPath.class || !currentPath.node) {
                        logger.error('edit-template', 'Invalid node path for editing template');
                        return;
                    }
                    const nodePath = `${currentPath.family}/${currentPath.class}/${currentPath.node}`;
                    const url = `{{ url_for("config.manage_template", node_path="") }}${nodePath}?template=${encodeURIComponent(template.name)}`;
                    logger.debug('edit-template', 'Navigating to template editor', { url });
                    window.location.href = url;
                };
                
                item.appendChild(leftSection);
                item.appendChild(editBtn);
                templateList.appendChild(item);
            });
            
            // Load saved selections after templates are loaded, passing available templates
            loadTemplateSelections(templates);
        })
        .catch(error => {
            logger.error('templates', 'Failed to load templates', { error: error.message });
            // Clear template list and selections on error
            document.getElementById('templateList').innerHTML = '';
            currentPath.templates = [];
            saveTemplateSelections();
        });
    saveCurrentPath();
}

// Modified createComplexDataInput function
function createComplexDataInput(key, value, template, parentPath = '') {
    const container = document.createElement('div');
    container.className = 'complex-data mb-3';

    if (Array.isArray(value)) {
        // Handle array type
        const arrayContainer = document.createElement('div');
        arrayContainer.className = 'array-container';
        
        value.forEach((item, index) => {
            const itemContainer = document.createElement('div');
            itemContainer.className = 'array-item mb-2';
            
            if (typeof item === 'object' && item !== null) {
                // Complex array item (object)
                const itemDiv = document.createElement('div');
                itemDiv.className = 'interface-item';
                
                Object.entries(item).forEach(([itemKey, itemValue]) => {
                    const formGroup = document.createElement('div');
                    formGroup.className = 'row mb-2 align-items-center';
                    
                    const labelCol = document.createElement('div');
                    labelCol.className = 'col-4';
                    const label = document.createElement('label');
                    label.className = 'mb-0';
                    label.textContent = itemKey;
                    labelCol.appendChild(label);
                    
                    const inputCol = document.createElement('div');
                    inputCol.className = 'col-8';
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'value-display p-2';
                    valueSpan.textContent = itemValue;
                    inputCol.appendChild(valueSpan);
                    
                    formGroup.appendChild(labelCol);
                    formGroup.appendChild(inputCol);
                    itemDiv.appendChild(formGroup);
                });
                
                itemContainer.appendChild(itemDiv);
            } else {
                // Simple array item
                const valueSpan = document.createElement('span');
                valueSpan.className = 'value-display p-2';
                valueSpan.textContent = item;
                itemContainer.appendChild(valueSpan);
            }
            
            arrayContainer.appendChild(itemContainer);
            
            // Add divider if not the last item
            if (index < value.length - 1) {
                const divider = document.createElement('hr');
                divider.className = 'interface-divider';
                arrayContainer.appendChild(divider);
            }
        });
        
        container.appendChild(arrayContainer);
    } else if (typeof value === 'object' && value !== null) {
        // Handle object type
        const objectContainer = document.createElement('div');
        objectContainer.className = 'ps-3 border-start';
        
        Object.entries(value).forEach(([objKey, objValue]) => {
            const formGroup = document.createElement('div');
            formGroup.className = 'row mb-2 align-items-center';
            
            const labelCol = document.createElement('div');
            labelCol.className = 'col-4';
            const label = document.createElement('label');
            label.className = 'mb-0';
            label.textContent = objKey;
            labelCol.appendChild(label);
            
            const inputCol = document.createElement('div');
            inputCol.className = 'col-8';
            
            if (typeof objValue === 'object' && objValue !== null) {
                inputCol.appendChild(createComplexDataInput(objKey, objValue, template, `${key}.`));
            } else {
                const valueSpan = document.createElement('span');
                valueSpan.className = 'value-display p-2';
                valueSpan.textContent = objValue;
                inputCol.appendChild(valueSpan);
            }
            
            formGroup.appendChild(labelCol);
            formGroup.appendChild(inputCol);
            objectContainer.appendChild(formGroup);
        });
        
        container.appendChild(objectContainer);
    }
    
    return container;
}

// Add function to refresh template state and preview
function refreshTemplateState() {
    const nodePath = `${currentPath.family}/${currentPath.class}/${currentPath.node}`;
    const variableList = document.getElementById('variableList');
    variableList.innerHTML = '';
    
    logger.debug('template-state', 'Refreshing template state', {
        nodePath,
        selectedTemplates: currentPath.templates
    });
    
    if (currentPath.templates.length === 0) {
        document.getElementById('configPreview').textContent = '';
        logger.info('template-state', 'No templates selected, clearing preview');
        return;
    }
    
    // Load variables for all selected templates
    Promise.all(currentPath.templates.map(template =>
        fetch(`{{ url_for("config.get_variables", node_path="", template_name="") }}${nodePath}/${template}`)
            .then(response => response.json())
    )).then(variableSets => {
        logger.debug('template-state', 'Loaded variables for templates', {
            templates: currentPath.templates,
            variableSets
        });
        
        variableSets.forEach((variables, idx) => {
            const template = currentPath.templates[idx];
            const section = document.createElement('div');
            section.className = 'template-section';
            
            const title = document.createElement('div');
            title.className = 'template-header';
            title.textContent = template;
            section.appendChild(title);
            
            Object.entries(variables).forEach(([key, value]) => {
                if (typeof value === 'object' && value !== null) {
                    // Complex data type
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'mb-2';
                    const label = document.createElement('label');
                    label.className = 'fw-bold';
                    label.textContent = key;
                    labelDiv.appendChild(label);
                    section.appendChild(labelDiv);
                    section.appendChild(createComplexDataInput(key, value, template));
                } else {
                    // Simple data type
                    const group = document.createElement('div');
                    group.className = 'row mb-2 align-items-center';
                    
                    const labelCol = document.createElement('div');
                    labelCol.className = 'col-4';
                    const label = document.createElement('label');
                    label.className = 'mb-0';
                    label.textContent = key;
                    labelCol.appendChild(label);
                    
                    const inputCol = document.createElement('div');
                    inputCol.className = 'col-8';
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'value-display p-2';
                    valueSpan.textContent = value;
                    inputCol.appendChild(valueSpan);
                    
                    group.appendChild(labelCol);
                    group.appendChild(inputCol);
                    section.appendChild(group);
                }
            });
            
            variableList.appendChild(section);
        });
        
        // Update preview with all selected templates
        refreshPreview();
    })
    .catch(error => {
        logger.error('template-state', 'Failed to refresh template state', { error: error.message });
    });
}

// Update the refreshPreview function to include logging
function refreshPreview() {
    const nodePath = `${currentPath.family}/${currentPath.class}/${currentPath.node}`;
    
    // Create query string with selected templates
    const templateParams = currentPath.templates.map(t => `template=${encodeURIComponent(t)}`).join('&');
    const url = `{{ url_for("config.get_preview", node_path="") }}${nodePath}?${templateParams}`;
    
    logger.debug('preview', 'Refreshing preview', {
        nodePath,
        selectedTemplates: currentPath.templates,
        url
    });
    
    fetch(url)
        .then(response => response.json())
        .then(data => {
            document.getElementById('configPreview').textContent = data.content;
            logger.info('preview', 'Preview updated successfully');
        })
        .catch(error => {
            logger.error('preview', 'Failed to update preview', { error: error.message });
        });
}

// Update the updatePreviewOnly function
function updatePreviewOnly(template, key, value) {
    const nodePath = `${currentPath.family}/${currentPath.class}/${currentPath.node}`;
    
    logger.debug('preview-only', 'Updating preview only', {
        template,
        key,
        value,
        nodePath
    });
    
    fetch(`{{ url_for("config.get_variables", node_path="", template_name="") }}${nodePath}/${template}`)
        .then(response => response.json())
        .then(data => {
            // Create a copy of the current data
            const previewData = {...data};
            // Update only the interfaces for preview
            previewData[key] = value;
            
            logger.debug('preview-only', 'Updating variables for preview', {
                template,
                updatedData: previewData
            });
            
            // Update the variables first
            return fetch(`{{ url_for("config.get_variables", node_path="", template_name="") }}${nodePath}/${template}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    variable: key,
                    value: value,
                    preview_only: true
                })
            });
        })
        .then(() => {
            // Create query string with selected templates
            const templateParams = currentPath.templates.map(t => `template=${encodeURIComponent(t)}`).join('&');
            const url = `{{ url_for("config.get_preview", node_path="") }}${nodePath}?${templateParams}`;
            logger.debug('preview', 'Updating preview', { url });
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('configPreview').textContent = data.content;
                    logger.info('preview', 'Preview updated successfully');
                })
                .catch(error => {
                    logger.error('preview', 'Failed to update preview', { error: error.message });
                });
        })
        .catch(error => {
            logger.error('preview-only', 'Failed to update preview', { error: error.message });
        });
}

// Update configuration preview
function updatePreview() {
    const nodePath = `${currentPath.family}/${currentPath.class}/${currentPath.node}`;
    
    // First get all variables for selected templates
    Promise.all(currentPath.templates.map(template =>
        fetch(`{{ url_for("config.get_variables", node_path="", template_name="") }}${nodePath}/${template}`)
            .then(response => response.json())
    )).then(() => {
        // Then get the preview
        const templateParams = currentPath.templates.map(t => `template=${encodeURIComponent(t)}`).join('&');
        return fetch(`{{ url_for("config.get_preview", node_path="") }}${nodePath}?${templateParams}`);
    })
    .then(response => response.json())
    .then(data => {
        document.getElementById('configPreview').textContent = data.content;
    });
}

// Function to create edit button for template
function createEditButton(template) {
    const editBtn = document.createElement('button');
    editBtn.className = 'btn btn-sm btn-outline-secondary';
    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
    editBtn.onclick = () => {
        const nodePath = `${currentPath.family}/${currentPath.class}/${currentPath.node}`;
        const encodedPath = encodeURIComponent(nodePath);
        window.location.href = `{{ url_for("config.manage_template", node_path="PLACEHOLDER") }}`.replace('PLACEHOLDER', encodedPath) + 
            `?template=${encodeURIComponent(template)}`;
    };
    return editBtn;
}

// Update template list creation
function updateTemplateList(templates) {
    const templateList = document.getElementById('templateList');
    templateList.innerHTML = '';
    
    templates.forEach(template => {
        const item = document.createElement('div');
        item.className = 'list-group-item d-flex justify-content-between align-items-center';
        
        const checkbox = document.createElement('div');
        checkbox.className = 'form-check';
        
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'form-check-input';
        input.id = `template-${template}`;
        input.dataset.template = template;
        input.checked = currentPath.templates.includes(template);
        input.onchange = () => handleTemplateSelection(input);
        
        const label = document.createElement('label');
        label.className = 'form-check-label';
        label.htmlFor = `template-${template}`;
        label.textContent = template;
        
        checkbox.appendChild(input);
        checkbox.appendChild(label);
        
        const editBtn = createEditButton(template);
        
        item.appendChild(checkbox);
        item.appendChild(editBtn);
        templateList.appendChild(item);
    });
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    // First load the structure and wait for it to complete
    fetch('{{ url_for("config.get_structure") }}')
        .then(response => response.json())
        .then(data => {
            // Store the structure data globally
            window.structureData = data;
            
            // Build the initial family list
            const familyList = document.getElementById('nodeFamilyList');
            familyList.innerHTML = '';
            
            data.families.forEach(family => {
                const item = document.createElement('a');
                item.href = '#';
                item.className = 'list-group-item list-group-item-action py-2';
                item.textContent = family.name;
                item.onclick = () => selectFamily(family);
                familyList.appendChild(item);
            });
            
            // After structure is loaded, try to restore the saved path
            const savedPath = localStorage.getItem('configHubPath');
            if (savedPath) {
                try {
                    const path = JSON.parse(savedPath);
                    if (path.family && path.class && path.node) {
                        // Find the saved family in our loaded structure
                        const savedFamily = data.families.find(f => f.name === path.family);
                        if (savedFamily) {
                            // Store templates to restore later
                            const templatesToRestore = path.templates || [];
                            
                            // First select the family
                            selectFamily(savedFamily);
                            
                            // Find and select the saved class
                            const savedClass = savedFamily.classes.find(c => c.name === path.class);
                            if (savedClass) {
                                setTimeout(() => {
                                    selectClass(savedClass);
                                    
                                    // Find and select the saved node
                                    const savedNode = savedClass.nodes.find(n => n.name === path.node);
                                    if (savedNode) {
                                        setTimeout(() => {
                                            // Store templates in currentPath before selecting node
                                            currentPath.templates = templatesToRestore;
                                            selectNode(savedNode);
                                        }, 100);
                                    }
                                }, 100);
                            }
                        }
                    }
                } catch (error) {
                    logger.error('path-restore', 'Failed to restore path', { error: error.message });
                    localStorage.removeItem('configHubPath');
                }
            }
        })
        .catch(error => {
            logger.error('structure', 'Failed to load structure', { error: error.message });
        });

    // Add sync button handler
    document.getElementById('syncButton').onclick = () => {
        const statusSpan = document.getElementById('syncStatus');
        statusSpan.textContent = 'Syncing...';
        
        fetch('{{ url_for("config.sync_repo") }}')
            .then(response => response.json())
            .then(data => {
                statusSpan.textContent = data.message;
                setTimeout(() => {
                    statusSpan.textContent = '';
                    loadStructure();
                }, 2000);
            })
            .catch(error => {
                statusSpan.textContent = 'Sync failed';
                logger.error('sync', 'Failed to sync repository', { error: error.message });
            });
    };

    // Add template button handler
    document.getElementById('addTemplateBtn').onclick = () => {
        if (!currentPath.family || !currentPath.class || !currentPath.node) {
            logger.error('add-template', 'Cannot add template - no node selected');
            return;
        }
        const nodePath = `${currentPath.family}/${currentPath.class}/${currentPath.node}`;
        const encodedPath = encodeURIComponent(nodePath);
        window.location.href = `{{ url_for("config.manage_template", node_path="PLACEHOLDER") }}`.replace('PLACEHOLDER', encodedPath);
    };
});
</script>
{% endblock %}